/**
 * Data Layer - Supabase Cache with Koios Fallback
 * Fast reads from Supabase with automatic freshness checks and sync triggering
 */

import { createClient } from './supabase';
import { getEnrichedDReps, EnrichedDRep } from './koios';
import { isWellDocumented } from '@/utils/documentation';

const CACHE_FRESHNESS_MINUTES = 15;

/**
 * Transform Supabase row to EnrichedDRep
 * Full transformation with all fields preserved for API route serving
 */
function transformSupabaseRowToDRep(row: any): EnrichedDRep {
  const info = row.info || {};
  
  return {
    drepId: row.id,
    drepHash: info.drepHash || '',
    handle: info.handle || null,
    name: info.name || null,
    ticker: info.ticker || null,
    description: info.description || null,
    votingPower: info.votingPower || 0,
    votingPowerLovelace: info.votingPowerLovelace || '0',
    participationRate: row.participation_rate || 0,
    rationaleRate: row.rationale_rate || 0,
    reliabilityScore: row.reliability_score || 0,
    reliabilityStreak: row.reliability_streak ?? 0,
    reliabilityRecency: row.reliability_recency ?? 0,
    reliabilityLongestGap: row.reliability_longest_gap ?? 0,
    reliabilityTenure: row.reliability_tenure ?? 0,
    deliberationModifier: row.deliberation_modifier || 1.0,
    effectiveParticipation: row.effective_participation || row.participation_rate || 0,
    sizeTier: row.size_tier || 'Small',
    delegatorCount: info.delegatorCount || 0,
    totalVotes: info.totalVotes || 0,
    yesVotes: info.yesVotes || 0,
    noVotes: info.noVotes || 0,
    abstainVotes: info.abstainVotes || 0,
    isActive: info.isActive || false,
    anchorUrl: info.anchorUrl || null,
    metadata: row.metadata || null,
    drepScore: row.score || 0,
    epochVoteCounts: info.epochVoteCounts || [],
    profileCompleteness: row.profile_completeness || 0,
    alignmentTreasuryConservative: row.alignment_treasury_conservative ?? null,
    alignmentTreasuryGrowth: row.alignment_treasury_growth ?? null,
    alignmentDecentralization: row.alignment_decentralization ?? null,
    alignmentSecurity: row.alignment_security ?? null,
    alignmentInnovation: row.alignment_innovation ?? null,
    alignmentTransparency: row.alignment_transparency ?? null,
    lastVoteTime: row.last_vote_time ?? null,
    updatedAt: row.updated_at ?? null,
  };
}

/**
 * Trigger background sync without blocking
 * Note: In production, this should be handled by a cron job or external trigger
 */
async function triggerBackgroundSync() {
  const isDev = process.env.NODE_ENV === 'development';
  
  if (isDev) {
    console.log('[Data] ⚠ Data is stale (>15min), sync recommended');
    console.log('[Data] Run: npm run sync');
  }
  
  // In production, this would trigger a webhook or queue job
  // For now, we just log a warning
}

/**
 * Get all DReps with caching and fallback
 * Returns same structure as getEnrichedDReps() for drop-in replacement
 */
export async function getAllDReps(): Promise<{
  dreps: EnrichedDRep[];
  allDReps: EnrichedDRep[];
  error: boolean;
  totalAvailable: number;
}> {
  const isDev = process.env.NODE_ENV === 'development';
  
  try {
    if (isDev) {
      console.log('[Data] Querying Supabase cache...');
    }
    
    const supabase = createClient();
    
    // Query all DReps ordered by score
    const { data: rows, error: supabaseError } = await supabase
      .from('dreps')
      .select('*')
      .order('score', { ascending: false });
    
    if (supabaseError) {
      console.error('[Data] Supabase query failed:', supabaseError.message);
      throw new Error('Supabase unavailable');
    }
    
    // Check if we have data
    if (!rows || rows.length === 0) {
      console.warn('[Data] No data in Supabase, falling back to Koios');
      console.warn('[Data] Run: npm run sync');
      return await getEnrichedDReps(false);
    }
    
    if (isDev) {
      console.log(`[Data] ✓ Retrieved ${rows.length} DReps from Supabase`);
    }
    
    // Check freshness
    const timestamps = rows
      .map(r => r.updated_at ? new Date(r.updated_at).getTime() : 0)
      .filter(t => t > 0);
    
    if (timestamps.length > 0) {
      const maxTimestamp = Math.max(...timestamps);
      const maxUpdatedAt = new Date(maxTimestamp);
      const freshnessThreshold = new Date(Date.now() - CACHE_FRESHNESS_MINUTES * 60 * 1000);
      const isStale = maxUpdatedAt < freshnessThreshold;
      
      if (isStale) {
        const ageMinutes = Math.round((Date.now() - maxTimestamp) / 1000 / 60);
        if (isDev) {
          console.log(`[Data] ⚠ Cache is stale (${ageMinutes} min old)`);
        }
        // Trigger sync in background (non-blocking)
        triggerBackgroundSync();
      } else if (isDev) {
        const ageMinutes = Math.round((Date.now() - maxTimestamp) / 1000 / 60);
        console.log(`[Data] ✓ Cache is fresh (${ageMinutes} min old)`);
      }
    }
    
    // Transform Supabase rows to EnrichedDRep[] (full data)
    const allDReps = rows.map(transformSupabaseRowToDRep);
    
    // Filter to well-documented DReps (default view)
    const wellDocumentedDReps = allDReps.filter(d => isWellDocumented(d));
    
    if (isDev) {
      console.log(`[Data] Well documented: ${wellDocumentedDReps.length}/${allDReps.length}`);
    }
    
    return {
      dreps: wellDocumentedDReps,
      allDReps: allDReps,
      error: false,
      totalAvailable: allDReps.length,
    };
    
  } catch (error: any) {
    console.error('[Data] Cache read failed, falling back to Koios:', error.message);
    
    // Fallback to direct Koios fetch
    if (isDev) {
      console.log('[Data] Fetching directly from Koios (slow)...');
    }
    
    return await getEnrichedDReps(false);
  }
}

/**
 * Get proposal counts per epoch using lifecycle-aware counting.
 * Each proposal is counted in every epoch it was active (from proposed_epoch
 * through the earliest of expired/ratified/dropped epoch, or current epoch).
 * Returns Map<epoch, proposalCount> for reliability scoring.
 */
export async function getActiveProposalEpochs(): Promise<Map<number, number>> {
  try {
    const supabase = createClient();

    const { data: rows, error } = await supabase
      .from('proposals')
      .select('proposed_epoch, expired_epoch, ratified_epoch, dropped_epoch')
      .not('proposed_epoch', 'is', null);

    if (error || !rows) return new Map();

    // Derive current epoch from timestamp
    const SHELLEY_GENESIS = 1596491091;
    const EPOCH_LEN = 432000;
    const SHELLEY_BASE = 209;
    const currentEpoch = Math.floor((Date.now() / 1000 - SHELLEY_GENESIS) / EPOCH_LEN) + SHELLEY_BASE;

    const counts = new Map<number, number>();
    for (const row of rows) {
      if (row.proposed_epoch == null) continue;
      const start = row.proposed_epoch;
      // End epoch is the earliest lifecycle termination, or current epoch
      const endEpoch = Math.min(
        ...[row.expired_epoch, row.ratified_epoch, row.dropped_epoch, currentEpoch]
          .filter((e): e is number => e != null)
      );
      for (let e = start; e <= endEpoch; e++) {
        counts.set(e, (counts.get(e) || 0) + 1);
      }
    }

    return counts;
  } catch {
    return new Map();
  }
}

/**
 * Get the actual total number of governance proposals from the proposals table.
 * Used as the denominator for participation rate calculations.
 */
export async function getActualProposalCount(): Promise<number> {
  try {
    const supabase = createClient();

    const { count, error } = await supabase
      .from('proposals')
      .select('*', { count: 'exact', head: true });

    if (error) {
      console.warn('[Data] getActualProposalCount query failed:', error.message);
      return 88; // fallback based on known count
    }

    return count && count > 0 ? count : 88;
  } catch (err) {
    console.error('[Data] getActualProposalCount error:', err);
    return 88;
  }
}

/**
 * Proposal metadata from the cached proposals table
 */
export interface CachedProposal {
  txHash: string;
  proposalIndex: number;
  title: string | null;
  abstract: string | null;
  aiSummary: string | null;
  proposalType: string | null;
  withdrawalAmount: number | null;
  treasuryTier: string | null;
  relevantPrefs: string[];
}

/**
 * Get proposals by their IDs (tx_hash + proposal_index)
 * Used to enrich vote records with proposal metadata
 */
export async function getProposalsByIds(
  proposalIds: { txHash: string; index: number }[]
): Promise<Map<string, CachedProposal>> {
  const result = new Map<string, CachedProposal>();
  
  if (proposalIds.length === 0) return result;
  
  try {
    const supabase = createClient();
    
    // Build a filter for all the proposal IDs
    // Note: Supabase doesn't support compound key IN queries easily,
    // so we'll fetch all proposals and filter client-side for simplicity
    const txHashes = [...new Set(proposalIds.map(p => p.txHash))];
    
    const { data: rows, error } = await supabase
      .from('proposals')
      .select('tx_hash, proposal_index, title, abstract, ai_summary, proposal_type, withdrawal_amount, treasury_tier, relevant_prefs')
      .in('tx_hash', txHashes);
    
    if (error) {
      console.warn('[Data] getProposalsByIds query failed:', error.message);
      return result;
    }
    
    if (!rows || rows.length === 0) {
      console.warn('[Data] getProposalsByIds: no proposals found for', txHashes.length, 'tx hashes');
      return result;
    }
    
    // Supabase doesn't support compound-key IN queries; we filter client-side after fetching by tx_hash
    const requestedIds = new Set(proposalIds.map(p => `${p.txHash}-${p.index}`));
    
    for (const row of rows) {
      const key = `${row.tx_hash}-${row.proposal_index}`;
      if (requestedIds.has(key)) {
        result.set(key, {
          txHash: row.tx_hash,
          proposalIndex: row.proposal_index,
          title: row.title,
          abstract: row.abstract,
          aiSummary: row.ai_summary || null,
          proposalType: row.proposal_type,
          withdrawalAmount: row.withdrawal_amount,
          treasuryTier: row.treasury_tier,
          relevantPrefs: row.relevant_prefs || [],
        });
      }
    }
    
    return result;
  } catch (err) {
    console.error('[Data] getProposalsByIds error:', err);
    return result;
  }
}

export interface RationaleRecord {
  rationaleText: string | null;
  rationaleAiSummary: string | null;
}

/**
 * Get cached rationale text and AI summary for votes by their tx hashes
 */
export async function getRationalesByVoteTxHashes(
  voteTxHashes: string[]
): Promise<Map<string, RationaleRecord>> {
  const result = new Map<string, RationaleRecord>();
  
  if (voteTxHashes.length === 0) return result;
  
  try {
    const supabase = createClient();
    
    const { data: rows, error } = await supabase
      .from('vote_rationales')
      .select('vote_tx_hash, rationale_text, ai_summary')
      .in('vote_tx_hash', voteTxHashes);
    
    if (error) {
      console.warn('[Data] getRationalesByVoteTxHashes query failed:', error.message);
      return result;
    }
    
    if (!rows) return result;
    
    for (const row of rows) {
      result.set(row.vote_tx_hash, {
        rationaleText: row.rationale_text || null,
        rationaleAiSummary: row.ai_summary || null,
      });
    }
    
    return result;
  } catch (err) {
    console.error('[Data] getRationalesByVoteTxHashes error:', err);
    return result;
  }
}

/**
 * Row shape returned from the drep_votes table
 */
export interface DRepVoteRow {
  vote_tx_hash: string;
  drep_id: string;
  proposal_tx_hash: string;
  proposal_index: number;
  vote: 'Yes' | 'No' | 'Abstain';
  epoch_no: number | null;
  block_time: number;
  meta_url: string | null;
  meta_hash: string | null;
}

/**
 * Get all votes for a specific DRep from Supabase
 * Ordered by block_time DESC (most recent first)
 */
export async function getVotesByDRepId(drepId: string): Promise<DRepVoteRow[]> {
  try {
    const supabase = createClient();

    const { data: rows, error } = await supabase
      .from('drep_votes')
      .select('*')
      .eq('drep_id', drepId)
      .order('block_time', { ascending: false });

    if (error) {
      console.warn('[Data] getVotesByDRepId query failed:', error.message);
      return [];
    }

    return (rows as DRepVoteRow[]) || [];
  } catch (err) {
    console.error('[Data] getVotesByDRepId error:', err);
    return [];
  }
}

/**
 * Get a single DRep by ID
 * Returns DRep data or null if not found
 */
export async function getDRepById(drepId: string): Promise<EnrichedDRep | null> {
  const isDev = process.env.NODE_ENV === 'development';
  
  try {
    if (isDev) {
      console.log(`[Data] Querying Supabase for DRep: ${drepId}`);
    }
    
    const supabase = createClient();
    
    const { data: row, error: supabaseError } = await supabase
      .from('dreps')
      .select('*')
      .eq('id', drepId)
      .single();
    
    if (supabaseError) {
      console.error('[Data] Supabase query failed:', supabaseError.message);
      throw new Error('Supabase unavailable');
    }
    
    if (!row) {
      if (isDev) {
        console.warn(`[Data] DRep ${drepId} not found in cache`);
      }
      return null;
    }
    
    if (isDev) {
      console.log(`[Data] ✓ Found DRep ${drepId} in cache`);
    }
    
    return transformSupabaseRowToDRep(row);
    
  } catch (error: any) {
    console.error('[Data] Cache read failed for DRep:', drepId, error.message);
    
    return null;
  }
}

// ============================================================================
// PROPOSALS SECTION DATA
// ============================================================================

export interface ProposalWithVoteSummary {
  txHash: string;
  proposalIndex: number;
  title: string | null;
  abstract: string | null;
  proposalType: string;
  withdrawalAmount: number | null;
  treasuryTier: string | null;
  relevantPrefs: string[];
  proposedEpoch: number | null;
  blockTime: number | null;
  aiSummary: string | null;
  yesCount: number;
  noCount: number;
  abstainCount: number;
  totalVotes: number;
  voterDrepIds: string[];
}

/**
 * Get all proposals with vote summary counts.
 * Fetches proposals from Supabase and aggregates votes.
 */
export async function getAllProposalsWithVoteSummary(): Promise<ProposalWithVoteSummary[]> {
  try {
    const supabase = createClient();

    // Fetch all proposals
    const { data: proposals, error: pError } = await supabase
      .from('proposals')
      .select('*')
      .order('block_time', { ascending: false });

    if (pError || !proposals) {
      console.warn('[Data] getAllProposals query failed:', pError?.message);
      return [];
    }

    // Fetch vote counts + voter DRep IDs grouped by proposal
    const { data: voteCounts, error: vError } = await supabase
      .from('drep_votes')
      .select('proposal_tx_hash, proposal_index, vote, drep_id');

    if (vError) {
      console.warn('[Data] vote counts query failed:', vError.message);
    }

    // Aggregate vote counts + voter DRep IDs per proposal
    const countMap = new Map<string, { yes: number; no: number; abstain: number; drepIds: Set<string> }>();
    if (voteCounts) {
      for (const v of voteCounts) {
        const key = `${v.proposal_tx_hash}-${v.proposal_index}`;
        const entry = countMap.get(key) || { yes: 0, no: 0, abstain: 0, drepIds: new Set<string>() };
        if (v.vote === 'Yes') entry.yes++;
        else if (v.vote === 'No') entry.no++;
        else entry.abstain++;
        if (v.drep_id) entry.drepIds.add(v.drep_id);
        countMap.set(key, entry);
      }
    }

    return proposals.map((p: any) => {
      const key = `${p.tx_hash}-${p.proposal_index}`;
      const counts = countMap.get(key) || { yes: 0, no: 0, abstain: 0, drepIds: new Set<string>() };
      return {
        txHash: p.tx_hash,
        proposalIndex: p.proposal_index,
        title: p.title,
        abstract: p.abstract,
        proposalType: p.proposal_type,
        withdrawalAmount: p.withdrawal_amount,
        treasuryTier: p.treasury_tier,
        relevantPrefs: p.relevant_prefs || [],
        proposedEpoch: p.proposed_epoch,
        blockTime: p.block_time,
        aiSummary: p.ai_summary || null,
        yesCount: counts.yes,
        noCount: counts.no,
        abstainCount: counts.abstain,
        totalVotes: counts.yes + counts.no + counts.abstain,
        voterDrepIds: [...counts.drepIds],
      };
    });
  } catch (err) {
    console.error('[Data] getAllProposalsWithVoteSummary error:', err);
    return [];
  }
}

export interface ProposalVoteDetail {
  voteTxHash: string;
  drepId: string;
  drepName: string | null;
  vote: 'Yes' | 'No' | 'Abstain';
  blockTime: number;
  rationaleText: string | null;
  rationaleAiSummary: string | null;
  metaUrl: string | null;
}

/**
 * Get a single proposal with full metadata.
 */
export async function getProposalByKey(
  txHash: string,
  proposalIndex: number
): Promise<ProposalWithVoteSummary | null> {
  try {
    const supabase = createClient();

    const { data: row, error } = await supabase
      .from('proposals')
      .select('*')
      .eq('tx_hash', txHash)
      .eq('proposal_index', proposalIndex)
      .single();

    if (error || !row) return null;

    // Get vote counts + voter IDs
    const { data: votes } = await supabase
      .from('drep_votes')
      .select('vote, drep_id')
      .eq('proposal_tx_hash', txHash)
      .eq('proposal_index', proposalIndex);

    let yes = 0, no = 0, abstain = 0;
    const drepIds = new Set<string>();
    if (votes) {
      for (const v of votes) {
        if (v.vote === 'Yes') yes++;
        else if (v.vote === 'No') no++;
        else abstain++;
        if (v.drep_id) drepIds.add(v.drep_id);
      }
    }

    return {
      txHash: row.tx_hash,
      proposalIndex: row.proposal_index,
      title: row.title,
      abstract: row.abstract,
      proposalType: row.proposal_type,
      withdrawalAmount: row.withdrawal_amount,
      treasuryTier: row.treasury_tier,
      relevantPrefs: row.relevant_prefs || [],
      proposedEpoch: row.proposed_epoch,
      blockTime: row.block_time,
      aiSummary: row.ai_summary || null,
      yesCount: yes,
      noCount: no,
      abstainCount: abstain,
      totalVotes: yes + no + abstain,
      voterDrepIds: [...drepIds],
    };
  } catch (err) {
    console.error('[Data] getProposalByKey error:', err);
    return null;
  }
}

/**
 * Get all votes for a specific proposal, enriched with DRep names and rationale.
 */
export async function getVotesByProposal(
  txHash: string,
  proposalIndex: number
): Promise<ProposalVoteDetail[]> {
  try {
    const supabase = createClient();

    const { data: votes, error } = await supabase
      .from('drep_votes')
      .select('vote_tx_hash, drep_id, vote, block_time, meta_url')
      .eq('proposal_tx_hash', txHash)
      .eq('proposal_index', proposalIndex)
      .order('block_time', { ascending: false });

    if (error || !votes) return [];

    // Fetch DRep names
    const drepIds = [...new Set(votes.map(v => v.drep_id))];
    const { data: dreps } = await supabase
      .from('dreps')
      .select('id, info')
      .in('id', drepIds);

    const drepNameMap = new Map<string, string | null>();
    if (dreps) {
      for (const d of dreps) {
        drepNameMap.set(d.id, (d.info as any)?.name || null);
      }
    }

    // Fetch rationale text and AI summaries
    const voteTxHashes = votes.map(v => v.vote_tx_hash);
    const { data: rationales } = await supabase
      .from('vote_rationales')
      .select('vote_tx_hash, rationale_text, ai_summary')
      .in('vote_tx_hash', voteTxHashes);

    const rationaleTextMap = new Map<string, string>();
    const rationaleAiSummaryMap = new Map<string, string>();
    if (rationales) {
      for (const r of rationales) {
        if (r.rationale_text) rationaleTextMap.set(r.vote_tx_hash, r.rationale_text);
        if (r.ai_summary) rationaleAiSummaryMap.set(r.vote_tx_hash, r.ai_summary);
      }
    }

    return votes.map(v => ({
      voteTxHash: v.vote_tx_hash,
      drepId: v.drep_id,
      drepName: drepNameMap.get(v.drep_id) || null,
      vote: v.vote as 'Yes' | 'No' | 'Abstain',
      blockTime: v.block_time,
      rationaleText: rationaleTextMap.get(v.vote_tx_hash) || null,
      rationaleAiSummary: rationaleAiSummaryMap.get(v.vote_tx_hash) || null,
      metaUrl: v.meta_url,
    }));
  } catch (err) {
    console.error('[Data] getVotesByProposal error:', err);
    return [];
  }
}

// ============================================================================
// GOVERNANCE INBOX
// ============================================================================

export interface OpenProposal {
  txHash: string;
  proposalIndex: number;
  title: string | null;
  abstract: string | null;
  aiSummary: string | null;
  proposalType: string;
  withdrawalAmount: number | null;
  treasuryTier: string | null;
  relevantPrefs: string[];
  proposedEpoch: number | null;
  expirationEpoch: number | null;
  blockTime: number | null;
  yesCount: number;
  noCount: number;
  abstainCount: number;
  totalVotes: number;
}

/**
 * Get open proposals that a specific DRep has NOT voted on.
 * "Open" = no ratified, enacted, dropped, or expired epoch set.
 */
export async function getOpenProposalsForDRep(drepId: string): Promise<OpenProposal[]> {
  try {
    const supabase = createClient();

    // Fetch open proposals
    const { data: proposals, error: pError } = await supabase
      .from('proposals')
      .select('*')
      .is('ratified_epoch', null)
      .is('enacted_epoch', null)
      .is('dropped_epoch', null)
      .is('expired_epoch', null)
      .order('block_time', { ascending: false });

    if (pError || !proposals || proposals.length === 0) return [];

    // Fetch this DRep's votes to determine which proposals are already voted on
    const { data: drepVotes, error: vError } = await supabase
      .from('drep_votes')
      .select('proposal_tx_hash, proposal_index')
      .eq('drep_id', drepId);

    const votedKeys = new Set<string>();
    if (!vError && drepVotes) {
      for (const v of drepVotes) {
        votedKeys.add(`${v.proposal_tx_hash}-${v.proposal_index}`);
      }
    }

    // Fetch vote counts for open proposals
    const openTxHashes = proposals.map((p: any) => p.tx_hash);
    const { data: allVotes } = await supabase
      .from('drep_votes')
      .select('proposal_tx_hash, proposal_index, vote')
      .in('proposal_tx_hash', openTxHashes);

    const countMap = new Map<string, { yes: number; no: number; abstain: number }>();
    if (allVotes) {
      for (const v of allVotes) {
        const key = `${v.proposal_tx_hash}-${v.proposal_index}`;
        const entry = countMap.get(key) || { yes: 0, no: 0, abstain: 0 };
        if (v.vote === 'Yes') entry.yes++;
        else if (v.vote === 'No') entry.no++;
        else entry.abstain++;
        countMap.set(key, entry);
      }
    }

    // Filter to proposals the DRep hasn't voted on
    return proposals
      .filter((p: any) => !votedKeys.has(`${p.tx_hash}-${p.proposal_index}`))
      .map((p: any) => {
        const key = `${p.tx_hash}-${p.proposal_index}`;
        const counts = countMap.get(key) || { yes: 0, no: 0, abstain: 0 };
        return {
          txHash: p.tx_hash,
          proposalIndex: p.proposal_index,
          title: p.title,
          abstract: p.abstract,
          aiSummary: p.ai_summary || null,
          proposalType: p.proposal_type,
          withdrawalAmount: p.withdrawal_amount,
          treasuryTier: p.treasury_tier,
          relevantPrefs: p.relevant_prefs || [],
          proposedEpoch: p.proposed_epoch,
          expirationEpoch: p.expiration_epoch ?? null,
          blockTime: p.block_time,
          yesCount: counts.yes,
          noCount: counts.no,
          abstainCount: counts.abstain,
          totalVotes: counts.yes + counts.no + counts.abstain,
        };
      });
  } catch (err) {
    console.error('[Data] getOpenProposalsForDRep error:', err);
    return [];
  }
}

/**
 * Get proposals the DRep voted on in the current epoch (for streak tracking).
 */
export async function getVotedThisEpoch(drepId: string, currentEpoch: number): Promise<number> {
  try {
    const supabase = createClient();
    const { count, error } = await supabase
      .from('drep_votes')
      .select('*', { count: 'exact', head: true })
      .eq('drep_id', drepId)
      .eq('epoch_no', currentEpoch);

    if (error) return 0;
    return count || 0;
  } catch {
    return 0;
  }
}

// ============================================================================
// SCORE HISTORY
// ============================================================================

export interface ScoreSnapshot {
  date: string;
  score: number;
  effectiveParticipation: number;
  rationaleRate: number;
  reliabilityScore: number;
  profileCompleteness: number;
}

/**
 * Get daily score history for a DRep, ordered oldest-first for charting.
 */
export async function getScoreHistory(drepId: string): Promise<ScoreSnapshot[]> {
  try {
    const supabase = createClient();

    const { data: rows, error } = await supabase
      .from('drep_score_history')
      .select('snapshot_date, score, effective_participation, rationale_rate, reliability_score, profile_completeness')
      .eq('drep_id', drepId)
      .order('snapshot_date', { ascending: true });

    if (error || !rows) return [];

    return rows.map((r: any) => ({
      date: r.snapshot_date,
      score: r.score ?? 0,
      effectiveParticipation: r.effective_participation ?? 0,
      rationaleRate: r.rationale_rate ?? 0,
      reliabilityScore: r.reliability_score ?? 0,
      profileCompleteness: r.profile_completeness ?? 0,
    }));
  } catch (err) {
    console.error('[Data] getScoreHistory error:', err);
    return [];
  }
}

/**
 * Get the percentile rank of a DRep's score among all DReps.
 * Returns 0-100 (e.g. 72 means "higher than 72% of DReps").
 */
export async function getDRepPercentile(score: number): Promise<number> {
  try {
    const supabase = createClient();

    const [{ count: belowCount }, { count: totalCount }] = await Promise.all([
      supabase.from('dreps').select('*', { count: 'exact', head: true }).lt('score', score),
      supabase.from('dreps').select('*', { count: 'exact', head: true }),
    ]);

    if (!totalCount || totalCount === 0) return 0;
    return Math.round(((belowCount ?? 0) / totalCount) * 100);
  } catch (err) {
    console.error('[Data] getDRepPercentile error:', err);
    return 0;
  }
}

// ============================================================================
// SOCIAL LINK CHECKS
// ============================================================================

export interface SocialLinkCheck {
  uri: string;
  status: 'valid' | 'broken' | 'pending';
  httpStatus: number | null;
  lastCheckedAt: string | null;
}

/**
 * Get social link check results for a DRep.
 */
export async function getSocialLinkChecks(drepId: string): Promise<SocialLinkCheck[]> {
  try {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('social_link_checks')
      .select('uri, status, http_status, last_checked_at')
      .eq('drep_id', drepId);

    if (error || !data) return [];

    return data.map((r: any) => ({
      uri: r.uri,
      status: r.status as 'valid' | 'broken' | 'pending',
      httpStatus: r.http_status,
      lastCheckedAt: r.last_checked_at,
    }));
  } catch (err) {
    console.error('[Data] getSocialLinkChecks error:', err);
    return [];
  }
}

// ============================================================================
// CLAIM STATUS
// ============================================================================

/**
 * Check if a DRep has been claimed by any user.
 */
export async function isDRepClaimed(drepId: string): Promise<boolean> {
  try {
    const supabase = createClient();
    const { data, error } = await supabase
      .from('users')
      .select('wallet_address')
      .eq('claimed_drep_id', drepId)
      .limit(1);

    if (error) return false;
    return (data?.length ?? 0) > 0;
  } catch {
    return false;
  }
}
