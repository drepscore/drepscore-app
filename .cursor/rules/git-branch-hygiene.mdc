---
description: Worktree workflow, branch safety guardrails, and deployment rules
alwaysApply: true
---

# Git Worktree Workflow

## Directory Layout

```
C:\Users\dalto\drepscore\
  drepscore-app/           ← main (production, merges, hotfixes)
  drepscore-<feature>/     ← one per active feature branch
```

Each worktree has its own `node_modules`, `.env.local`, and `.next`. The git history is shared.

## Starting a Feature (Planning → Building)

**A plan document MUST exist before creating a worktree.** The plan is the handoff — it's how the new conversation in the worktree window knows what to build.

Pre-flight checklist (all steps mandatory, in order):

1. **Verify plan exists**: Confirm `.cursor/plans/<feature>.plan.md` is written and committed to `main`. If not, write and commit it first (`docs: plan for <feature>`).
2. **Create worktree and install deps**:
   ```
   git worktree add ..\drepscore-<name> -b feature/<name>
   Copy-Item .env.local ..\drepscore-<name>\.env.local
   cd ..\drepscore-<name>; npm install
   ```
3. **Open the worktree in a new Cursor window automatically**:
   ```
   cursor C:\Users\dalto\drepscore\drepscore-<name>
   ```
4. **Tell the user**:
   > A new Cursor window is opening for `drepscore-<name>`.
   > Start a new conversation there and say: **"Build the plan in `.cursor/plans/<feature>.plan.md`"**

The plan file is already in the worktree because it was committed to main before the worktree was created. The new agent reads it and has full context.

## Branch Detection Guardrail

**Before making ANY code changes**, check `git branch --show-current`.

- If on `main` and the task is NOT a quick hotfix: **STOP**. Create a worktree first.
- If on `main` and it IS a hotfix: proceed, but commit and push directly — no PR needed for single-commit hotfixes.
- If on a feature branch: proceed normally.

## Merge Guardrail — PR-Based Flow

**NEVER merge to main from a feature worktree.** Merges to main ONLY happen via PR.

When a feature is complete:

1. From the **feature worktree**, push the branch:
   ```
   git push origin feature/<name>
   ```
2. Create a PR:
   ```
   gh pr create --title "feat: <description>" --body "## Summary\n..."
   ```
3. Tell the user: "PR created. Switch to the `drepscore-app` window to merge when ready."

When the user says "merge" from the **main worktree** (`drepscore-app`):

1. Merge via GitHub CLI:
   ```
   gh pr merge <pr-number> --squash --delete-branch
   git pull origin main
   ```
2. Clean up the worktree:
   ```
   git worktree remove ..\drepscore-<name>
   git branch -d feature/<name>
   ```
3. If the feature touched sync routes or analytics: trigger a sync and/or verify the analytics deploy hook fired.

When the user says "merge" from a **feature worktree** (e.g. `drepscore-<name>`):

`gh pr merge` will fail because it tries to checkout main, which is locked by another worktree. Use the GitHub API directly:

```
gh api repos/drepscore/drepscore-app/pulls/<pr-number>/merge -X PUT -f merge_method=squash -f commit_title="feat: <description> (#<pr-number>)"
```

Then pull into the main worktree and clean up:
```
# From drepscore-app (main worktree):
git pull origin main
git worktree remove ..\drepscore-<name>
git branch -d feature/<name>
```

## Worktree Decision Logic

**Work directly on main (no worktree):**
- Single-commit fixes (typos, config, lint)
- Cursor rule / documentation updates
- Plan file creation (plans are authored on main by design)

**Worktree required:**
- Any plan with 2+ phases of code changes
- New features visible to users
- Database migrations bundled with code changes
- Multi-file refactors (10+ files)
- Anything that needs a PR per the release gating criteria in `deploy.md`

Single decision rule: **if it needs a PR, it needs a worktree.**

## Analytics Loaders

All `analytics/src/data/*.json.ts` files query Postgres directly at build time. When adding or modifying loaders:
- Verify column names against the actual DB schema (use Supabase MCP `execute_sql`)
- Use conditional env loading: `if (existsSync(envPath)) process.loadEnvFile(envPath)`
- Known gotchas: `notification_log` uses `sent_at` (not `created_at`); `drep_votes` PK is `vote_tx_hash` (no `id` column), epoch column is `epoch_no`

## Deployment

- **Production**: deploys from `main` via Railway Git integration (push = deploy)
- **Preview**: Railway auto-deploys every PR branch as an ephemeral preview environment
- **Analytics dashboard**: separate Observable Framework project in `analytics/`, deployed via Railway
- **Post-sync rebuild**: `dreps` and `votes` sync routes fire `ANALYTICS_DEPLOY_HOOK` automatically
- **Background jobs**: All syncs/crons run via Inngest Cloud (no cron secrets needed for scheduling)

## Deployment Monitoring

After merging to main, Railway deploys automatically. Monitor via:

```
gh api repos/drepscore/drepscore-app/commits/<sha>/status --jq '.statuses[] | {state, description}'
```

- Railway builds take 3-7 minutes. Poll every 60-120s.
- When status shows `success`, verify the actual endpoint (e.g. a new API route) returns 200 — don't rely solely on the status API.
- If status shows `failure`, check the Railway dashboard link in the `target_url` field.

## Build Failure Triage

Before debugging a build failure, **always verify it exists on the base branch first**:

```
git stash
npx next build 2>&1 | Select-String "Build error|Module not found"
git stash pop
```

This avoids wasting time on pre-existing issues (e.g. the Turbopack `libsodium-sumo.mjs` error with Mesh SDK — use `next build --webpack` to work around it).

## Shared Type Construction

When adding a field to a TypeScript interface, search for ALL places that construct that type — not just the API route. Server-side data fetching in `page.tsx` files often duplicates the same shape. Run `npx tsc --noEmit` after any interface change.
